package main

import (
	"bytes"
	"fmt"
	"github.com/pkg/errors"
	"go/format"
	"golang.org/x/tools/imports"
	"io"
	"log"
	"strings"
	"unicode"
)

func writeImports(w io.Writer, imports []string) {
	if len(imports) == 0 {
		return
	}

	fmt.Fprintln(w, "import (")

	for _, i := range imports {
		fmt.Fprintln(w, i)
	}

	fmt.Fprintln(w, ")")
}

func buildInputParams(fields []genField) string {
	var fieldList []string
	for _, f := range fields {
		if f.skip {
			continue
		} else if f.optional {
			fieldList = append(fieldList, fmt.Sprintf("%s *%s", f.name, f.typ))
		} else if f.array {
			fieldList = append(fieldList, fmt.Sprintf("%s []%s", f.name, f.typ))
		} else {
			fieldList = append(fieldList, fmt.Sprintf("%s %s", f.name, f.typ))
		}
	}

	return strings.Join(fieldList, ",")
}

func buildBody(name string, fields []genField) string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("result := &%s {\n", name))

	// process required fields
	for _, f := range fields {
		if f.skip || f.optional {
			continue
		}

		// if field is required and a pointer, then set to the address of the input param
		if f.ptr {
			sb.WriteString(fmt.Sprintf("%s: &%s,\n", f.name, f.name))
		} else {
			sb.WriteString(fmt.Sprintf("%s: %s,\n", f.name, f.name))
		}
	}

	sb.WriteString("}\n")

	// process optional fields
	for _, f := range fields {
		if f.skip || !f.optional {
			continue
		}

		if f.ptr {
			sb.WriteString(fmt.Sprintf("if %s != nil {\nresult.%s = %s\n}\n", f.name, f.name, f.name))
		} else {
			sb.WriteString(fmt.Sprintf("if %s != nil {\nresult.%s = *%s\n}\n", f.name, f.name, f.name))
		}
	}

	sb.WriteString("return result\n")

	return sb.String()
}

func formatStructName(in string) string {
	return "New" + string(unicode.ToUpper(rune(in[0]))) + in[1:]
}

func writeStruct(w io.Writer, s genStruct) {
	fmFuncName := formatStructName(s.name)
	comment := fmt.Sprintf("// %s generated factory method for %s", fmFuncName, s.name)

	// struct comment
	fmt.Fprintln(w, comment)

	// struct method signature
	fmt.Fprintf(w, "func %s(%s) *%s{\n", fmFuncName, buildInputParams(s.fields), s.name)

	// build struct body
	fmt.Fprintf(w, buildBody(s.name, s.fields))
	fmt.Fprintln(w, "}")
}

func writePackageFile(w io.Writer, pkg string, pkgImports []string, structs []genStruct) {
	var buf bytes.Buffer

	// write the header comment
	fmt.Fprintln(&buf, `// Code generated by "fmgen". DO NOT EDIT.`)

	// write the package
	fmt.Fprintln(&buf, fmt.Sprintf("package %s", pkg))

	// write the imports
	writeImports(&buf, pkgImports)

	// write factory methods for each struct
	for _, s := range structs {
		writeStruct(&buf, s)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Panicf("unable to copy source to buffer - %v", errors.WithStack(err))
	}

	output := fmt.Sprintf("%s/%s", pkg, generatedFileName)
	log.Printf("generating factory method file for package [%s]", pkg)

	processed, err := imports.Process(output, formatted, nil)
	if err != nil {
		log.Panicf("unable to process generated file to remove unused imports - %v", errors.WithStack(err))
	}

	_, err = io.Copy(w, bytes.NewReader(processed))
	if err != nil {
		log.Panicf("unable to copy processed results to writer - %v", errors.WithStack(err))
	}
}
